# 相手の座標と自身の座標を逆転させる必要ある

## 敵アクション座標逆転の実装完了

### 実装した変更点：

1. **座標逆転ヘルパー関数を追加**
   - `invertPosition()`メソッドを新規作成
   - グリッドの最大サイズ（`gridWidth`と`gridHeight`）から座標を逆転

2. **敵キャラクターの初期配置を修正**
   - 敵キャラクターを配置する際に逆転した座標を使用
   - 敵キャラクターの位置情報保存も逆転座標で管理

3. **敵のアクション実行を修正**
   - `executeAllActions()`メソッドで敵のアクションを処理する際に座標を逆転
   - `this.invertPosition(action.position)`で敵の移動先座標を逆転

4. **TypeScriptエラーを修正**
   - useEffectの依存配列に`currentTurn`を追加

### 動作説明：

- **現在の仕様**: 敵のキャラクターは元々プレイヤーと同じ座標系（上辺から配置）で動作していました
- **修正後**: 敵のキャラクターは座標が逆転されるため、プレイヤー側の下辺（グリッドの反対側）に配置され、アクションも逆転した座標で実行されます
- **効果**: 敵キャラクターがすぐにこちらの陣地に来ることがなくなり、適切な対戦バランスが保たれます

これで、敵のアクションが適切に逆転した座標で実行され、両者のキャラクターが適切な距離を保って対戦できるようになります。

# 左と上にも余白が必要

グリッドフィールドに余白を追加します。まず現在のファイルの状態を確認して、カメラの設定やワールドサイズの計算部分を見てみましょう。 `setupCamera`メソッドと`getHexPosition`メソッドを確認しましょう： まず、余白用のプロパティを追加し、画面サイズに基づいて余白を計算できるようにします。Phaserのゲームサイズにアクセスする必要があります： 余白の設定を追加しましょう。プロパティを追加して、`getHexPosition`と`setupCamera`メソッドを修正します： 

## グリッドフィールドの余白実装完了

### 実装した変更点：

1. **余白プロパティの追加**
   - `marginLeft`と`marginTop`プロパティを追加
   - 画面サイズに基づいて動的に余白を計算

2. **余白初期化メソッドの追加**
   - `initializeMargins()`メソッドを新規作成
   - ゲームキャンバスサイズの50%の余白を設定

3. **座標計算の修正**
   - `getHexPosition()`：余白を含めた座標計算に変更
   - `pixelToHex()`：マウス座標からヘックス座標への変換で余白を考慮

4. **カメラ設定の修正**
   - `setupCamera()`：ワールドサイズに余白を含めるように修正
   - カメラの境界とセンタリングを余白込みで設定

5. **初期化順序の調整**
   - `create()`メソッドで余白を最初に初期化するように変更

### 動作説明：

- **余白サイズ**: 画面の横幅と縦幅の50%ずつ左側と上部に余白を追加
- **グリッド位置**: すべてのヘックスタイルとキャラクターが余白分だけ右下にオフセット
- **カメラ**: 余白を含めた全体エリアを管理し、適切にセンタリング
- **マウス操作**: 余白を考慮した正確な座標変換でクリック判定

これにより、グリッドフィールドの左側と上部に十分な余白が確保され、より見やすく操作しやすいレイアウトになります。

# 一秒ずつアクションさせる必要がある

## アクション配列に従った段階的移動システムの実装完了

### 実装した変更点：

1. **プレイヤー用アクション配列移動メソッド**
   - `animatePlayerCharacterByActionSequence()`を新規作成
   - プレイヤーキャラクターは座標逆転なしで移動
   - アクション配列を順次実行

2. **敵キャラクター用アクション配列移動メソッド**
   - `animateCharacterByActionSequence()`を新規作成
   - 敵キャラクターは座標を逆転して移動
   - アクション配列を順次実行

3. **キャラクターIDごとのアクショングループ化**
   - プレイヤー・敵ともにキャラクターIDでアクションをグループ化
   - タイムスタンプでソート（古い順に実行）
   - 各キャラクターが独立してアクション配列を実行

4. **移動完了同期システム**
   - すべてのキャラクターのアクション完了を待機
   - 最後のアクションの方向情報を適用
   - 全移動完了後にフェーズ移行

### 動作説明：

**アクション処理フロー:**
1. `enemyActions`配列をキャラクターIDごとにグループ化
2. 各グループをタイムスタンプでソート
3. 各キャラクターが自身のアクション配列を1秒間隔で順次実行
4. 敵キャラクターは座標を逆転させて移動
5. すべてのキャラクターの移動完了後にフェーズ移行

**具体例:**
- キャラクター01: 3つのアクション → 3秒かけて移動
- キャラクター02: 3つのアクション → 3秒かけて移動
- キャラクター03: 3つのアクション → 3秒かけて移動
- キャラクター04: 2つのアクション → 2秒かけて移動

**同期動作:**
- すべてのキャラクターが同時に移動開始
- 各キャラクターは自分のアクション配列に従って段階的に移動
- 最も長いアクション配列（3秒）の完了を待って次フェーズへ

これで、`enemyActions`配列の内容に正確に従って、キャラクターが1秒間隔で段階的に移動するようになります。


